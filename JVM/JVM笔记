JVM探究
    面试题
    1.请你谈谈你对JVM的理解? java8虚拟机和之前的变化更新
    2.什么是OOM,什么是栈溢出StackOverFlowError?怎么分析
    3.JVM的常用调优参数有哪些
    4.内存快照如何抓取,怎么分析Dump文件?
    5.谈谈JVM中,类加载器你的认识

一.JVM的位置
    操作系统之下
二.JVM的体系结构

三.类加载器
   1.虚拟机自带的加载器
   2.启动类(根)加载器
   3.扩展类加载器
   4.应用程序加载器

   类加载的步骤
        1.类加载器收到类加载的请求.
        2.将这个请求向上委托给父类加载器去完成,一直向上托,直到跟加载器
        3.跟加载会检查是否能够加载当前这个类,能加载出来,使用当前的加载器,否则,抛出异常,通知子类加载器进行加载
        4.重复步骤 3

四.双亲委派机制
    原理:如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，
        如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，
        如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试
        自己去加载，这就是双亲委派模式，即每个儿子都很懒，每次有活就丢给父亲去干，直到父亲说这件事我也干
        不了时，儿子自己想办法去完成，这不就是传说中的实力坑爹啊？那么采用这种模式有啥用呢?

    双亲委派模式优势
        采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，
        通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader
        再加载一次。其次是考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络
        传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载
        器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的
        java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库
        被随意篡改。可能你会想，如果我们在classpath路径下自定义一个名为java.lang.SingleInterge类
        (该类是胡编的)呢？该类并不存在java.lang中，经过双亲委托模式，传递到启动类加载器中
        ，由于父类加载器路径下并没有该类，所以不会加载，将反向委托给子类加载器加载，最终会通
        过系统类加载器加载该类。但是这样做是不允许，因为java.lang是核心API包，需要访问权限，
        强制加载将会报出如下异常

五.沙箱安全机制
    Java安全模型的核心就是Java沙箱,什么是沙箱?沙箱是一个限制程序运行的环境,沙箱机制就是将Java代码限定在
        虚拟机(JVM)特定的运行范围内,并且严格限制代码对本地系统资源的访问,通过这样的措施来保证对代码的有效隔离,
        防止对本地系统造成损坏,沙箱只要限制系统资源访问,

    系统资源包括什么?
        CPU,内存,文件系统,网络,不同级别的沙箱对这些资源访问的限制也可以不一样

    所欲的java程序运行都可以指定沙箱,可以定制安全策略

    组成沙箱的基本组件
        字节码校验器:确保java类文件遵循java语言规范,这样可以帮助java程序实现内存保护.但并不是所有的
            类文件都会经过字节码检验,比如核心类.

        类装载器:其中类装载器在3个方面对java沙箱起作用
            它防止恶意代码去干涉善意代码,//双亲委派机制
            它保护了被信任的类库边界
            它将代码归入保护域,确定了代码可以进行那些操作


六.Native
    详见NativeTest.java
七.PC寄存器

八.方法去
    存static ,final,Class类信息,常量池
九.栈
    先进后出,后进先出.
    主管程序的运行,生命周期和线程同步
    线程结束,栈内存就释放了,对于栈来说,不存在垃圾回收问题,
    一旦线程结束,栈就over

    栈中主要存储:8大基本类型+对象的引用+实例的方法
    自己查,栈是怎么存储的

十.堆
    Heap,一个JVM只有一个堆内存,堆内存的大小是可以调节的

    类加载器读取了类文件后,一般会把什么东西放到堆中呢?<对象>
        类,方法,常量,变量~保存我们所有引用类型的真实对象

    堆内存中还要分为三个区域(详见画图板,"堆中的三个区域")
        新生区(Young/new)
        养老区(Old)
        永久区(Perm)
    GC垃圾挥手,主要实在伊甸园区和养老区
    假设内存满了,OOM,堆内存不够~  java.lang.OutOfMemoryError: Java heap space

    在JDK8以后,永久存储区改了名字:元空间;

十一.三种JVM
    Sun公司 HotSpot
    BEA JRockit
    IBM j9 VM

    我们学习的是HotSpot
十二.新生区,

    新生区:
        一个类诞生,和成长的地方,甚至死亡
        伊甸园区,所有的对象实在伊甸园区new出来的
        幸存者区(0,1)

     老年区:
    真理:经过研究,99%的对象都是临时对象!哈哈哈

十三.永久区.(jdk1.8之后元空间)
    这个区常驻内存的,用来存放JDK自身携带的Class对象,Interface元数据,存储的是java运行时的环境

    jdk1.6之前,永久代,这个时候常量池实在方法区中
    jdk1.7  :永久代,但是慢慢的退化了"去永久代",常量池在堆中
    jdk1.8之后:无永久代,常量池在元空间

    **元空间(Metaspace)
    hotspot中的永久代,JDK1.8之后hotspot移除了永久代使用元空间取而代之.

十四.堆内存调优
       详见HeapTest02.java
十五.GC(详见画图板 "GC常见算法")
    JVM在进行GC的时,并不是对这个三个区域统一回收,大部分时候,回收都是在新生代
        新生代
        幸存区(from to两个区)
        老年区

    GC两种类 : 轻GC 重GC
    1.常用算法 标记清除法, 标记整理, 复制算法, 引用计数器

十六.JMM:java memory model java内存模型
    1.什么是JMM
        JMM:(Java Memory Model的缩写)

    2.JMM是干嘛的
        作用:缓存一致性协议,用于定义数据读写的规则(遵守).
        JMM定义了线程工作内存和主内存之间的抽象关系:线程之间的共享变量存储在主内存当中,每个线程都有一个
            私有的本地内存(Local Memory)
        在Java虚拟机规范中试图定义一种Java内存模型（Java Memory Model，JMM）
            来屏蔽各个硬件平台和操作系统的内存访问差异，
            以实现让Java程序在各种平台下都能达到一致的内存访问效果

        解决共享对象可见性这个问题:volatile

    3.JMM该如何学习




GC题目
    JVM的内存模型和分区,详细到每个区放什么

    堆里面的分区都有那些 Eden from to Old

    GC的算法有哪些?标记清除法, 标记整理, 复制算法, 引用计数器,怎么用

    轻GC 和 重GC分别在什么时候发生


